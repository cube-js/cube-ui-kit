import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="tasty/Documentation" />

# Tasty Style Helper

`tasty` is a powerful utility for creating styled React components with a declarative, design-system-integrated API. It combines the flexibility of CSS-in-JS with the consistency of a design system, enabling you to build maintainable, themeable components quickly.

---

## üöÄ Quick Start

### Creating Your First Component

```jsx
import { tasty } from '@cube-dev/ui-kit';

// Basic styled component
const Card = tasty({
  as: 'div',
  styles: {
    padding: '4x',
    fill: '#white',
    border: true,
    radius: true,
  },
  styleProps: ['padding', 'fill'], // Expose styles as props
});

// Usage
<Card>Hello World</Card>
<Card padding="6x" fill="#gray.05">Custom Card</Card>
```

### Extending Existing Components

> **‚úÖ Best Practice:** Always prefer creating styled wrappers over using the `styles` prop directly.

```jsx
// ‚úÖ Recommended
const PrimaryButton = tasty(Button, {
  styles: {
    fill: '#purple',
    color: '#white',
    padding: '2x 4x',
  },
});

// ‚ùå Avoid
<Button styles={{ fill: '#purple' }}>Click me</Button>
```

### Essential Patterns

```jsx
// State-based styling
const InteractiveCard = tasty({
  styles: {
    fill: {
      '': '#white',
      'hovered': '#gray.05',
      'pressed': '#gray.10',
    },
  },
});

// Using design tokens
const TokenCard = tasty({
  styles: {
    fill: '#surface',      // Color token
    color: '#text',        // Color token
    padding: '2x',         // Custom unit (gap √ó 2)
    radius: '1r',          // Custom unit (border-radius)
    border: '1bw solid #border', // Border width token
  },
});
```

---

## ‚öôÔ∏è Configuration

Configure the Tasty style system before your app renders using the `configure()` function. Configuration must be done **before any styles are generated** (before first render).

```jsx
import { configure } from '@cube-dev/ui-kit';

// Configure before app renders (e.g., in your entry file)
configure({
  // CSP nonce for style elements
  nonce: 'abc123',

  // Global state aliases
  states: {
    '@mobile': '@media(w < 768px)',
    '@tablet': '@media(768px <= w < 1024px)',
    '@dark': '@root(theme=dark)',
  },

  // Parser configuration
  parserCacheSize: 2000, // LRU cache size (default: 1000)
  
  // Custom units (merged with built-in units)
  units: {
    vh: 'vh',
    vw: 'vw',
    custom: (n) => `${n * 10}px`, // Function-based unit
  },
  
  // Custom functions for the parser
  funcs: {
    double: (groups) => {
      const value = parseFloat(groups[0]?.output || '0');
      return `${value * 2}px`;
    },
  },
});
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `nonce` | `string` | - | CSP nonce for style elements |
| `states` | `Record<string, string>` | - | Global state aliases for advanced state mapping |
| `parserCacheSize` | `number` | `1000` | Parser LRU cache size |
| `units` | `Record<string, string \| Function>` | Built-in | Custom units (merged with built-in) |
| `funcs` | `Record<string, Function>` | - | Custom parser functions (merged with existing) |
| `handlers` | `Record<string, StyleHandlerDefinition>` | Built-in | Custom style handlers (replace built-in) |
| `tokens` | `Record<string, string \| number>` | - | Predefined tokens replaced during parsing |

### Predefined Tokens

Define reusable tokens that are replaced during style parsing. Unlike component-level `tokens` prop (which renders as inline CSS custom properties), predefined tokens are baked into the generated CSS.

```jsx
configure({
  tokens: {
    // Custom property tokens ($name)
    $spacing: '2x',
    '$card-padding': '4x',
    '$button-height': '40px',
    
    // Color tokens (#name)
    '#accent': '#purple',
    '#surface': '#white',
    '#surface-hover': '#gray.05',
  },
});

// Now use in styles - tokens are replaced at parse time
const Card = tasty({
  styles: {
    padding: '$card-padding',      // ‚Üí calc(4 * var(--gap))
    fill: '#surface',              // ‚Üí var(--white-color)
    border: '1bw solid #accent',   // ‚Üí 1px solid var(--purple-color)
  },
});

const Button = tasty({
  styles: {
    height: '$button-height',      // ‚Üí 40px
    fill: {
      '': '#accent',
      'hovered': '#surface-hover',
    },
  },
});
```

**Benefits of predefined tokens:**
- **Consistency** - Define design tokens once, use everywhere
- **Performance** - Values are baked into CSS, no runtime overhead
- **Caching** - Generated styles are cached and deduplicated
- **Type safety** - Use `$` prefix for values, `#` prefix for colors

**Predefined tokens vs component tokens:**

| Feature | Predefined (config) | Component (`tokens` prop) |
|---------|--------------------|-----------------------------|
| Scope | Global | Per-component instance |
| Output | Baked into CSS classes | Inline CSS custom properties |
| Runtime | Static | Dynamic (can change) |
| Use case | Design system values | Dynamic/computed values |

### Built-in Units

| Unit | Description | Example | CSS Output |
|------|-------------|---------|------------|
| `x` | Gap multiplier | `2x` | `calc(var(--gap) * 2)` |
| `r` | Border radius | `1r` | `var(--radius)` |
| `cr` | Card border radius | `1cr` | `var(--card-radius)` |
| `bw` | Border width | `2bw` | `calc(var(--border-width) * 2)` |
| `ow` | Outline width | `1ow` | `var(--outline-width)` |
| `fs` | Font size | `1fs` | `var(--font-size)` |
| `lh` | Line height | `1lh` | `var(--line-height)` |
| `sf` | Stable fraction | `1sf` | `minmax(0, 1fr)` |

### Adding Custom Units

Custom units are **merged** with built-in units - you can extend without losing defaults:

```jsx
configure({
  units: {
    // Add viewport units
    vh: 'vh',
    vw: 'vw',
    // Dynamic unit with function
    cols: (n) => `calc(${n} * var(--column-width))`,
  },
});

// Usage in components
const Box = tasty({
  styles: {
    height: '50vh',
    width: '3cols',
  },
});
```

### Raw Unit Calculation

When a custom unit is defined with a **raw CSS value** (like `8px`, `1rem`), the parser calculates the result directly instead of wrapping it in `calc()`:

```jsx
configure({
  units: {
    sp: '8px', // Raw CSS unit - calculated directly
  },
});

// Usage
padding: '2sp';  // ‚Üí 16px (calculated: 2 * 8px)
padding: '1sp';  // ‚Üí 8px
padding: '.5sp'; // ‚Üí 4px
```

This produces cleaner CSS output and is more efficient than `calc()` wrappers.

**Non-raw units** (CSS variables, functions, etc.) still use `calc()` for multiplication:

```jsx
configure({
  units: {
    gap: 'var(--gap)', // Non-raw - uses calc()
  },
});

// Usage
padding: '2gap'; // ‚Üí calc(2 * var(--gap))
```

### Recursive Unit Resolution

Custom units can reference other custom units. The parser resolves them recursively:

```jsx
configure({
  units: {
    x: '8px',  // Base unit
    y: '2x',   // References x ‚Üí 2 * 8px = 16px
    z: '2y',   // References y ‚Üí 2 * 16px = 32px
  },
});

// Usage
padding: '1x'; // ‚Üí 8px
padding: '1y'; // ‚Üí 16px (resolved from 2x)
padding: '1z'; // ‚Üí 32px (resolved from 2y ‚Üí 4x)
padding: '3y'; // ‚Üí 48px (3 * 16px)
```

This is useful for creating a spacing scale or other design system values that build upon each other.

### Adding Custom Functions

Custom functions process parsed style values:

```jsx
configure({
  funcs: {
    // Custom function: clamp(min, value, max)
    clamp: (groups) => {
      const values = groups.map(g => g.output);
      return `clamp(${values.join(', ')})`;
    },
  },
});

// Usage in components
const Box = tasty({
  styles: {
    width: 'clamp(200px, 50%, 800px)',
  },
});
```

### Custom Style Handlers

Style handlers transform style properties into CSS declarations. Custom handlers **replace** built-in handlers for the same style name.

```jsx
import { configure, styleHandlers } from '@cube-dev/ui-kit';

configure({
  handlers: {
    // Override fill with gradient support
    fill: ({ fill }) => {
      if (fill?.startsWith('gradient:')) {
        return { background: fill.slice(9) };
      }
      return styleHandlers.fill({ fill }); // Delegate to built-in
    },
    
    // Add new custom style
    elevation: ({ elevation }) => {
      const level = parseInt(elevation) || 1;
      return {
        'box-shadow': `0 ${level * 2}px ${level * 4}px rgba(0,0,0,0.1)`,
        'z-index': String(level * 100),
      };
    },
    
    // Multi-property handler
    customSpacing: [['gap', 'padding'], ({ gap, padding }) => ({
      gap: gap || '1x',
      padding: padding || '2x',
    })],
  },
});
```

**Handler definition forms:**
- Function only: `fill: (props) => ...` ‚Äî lookup style inferred from key name
- Single tuple: `['styleName', handler]` ‚Äî explicit lookup style
- Multi tuple: `[['style1', 'style2'], handler]` ‚Äî multiple lookup styles

Use `styleHandlers` export to delegate to built-in handlers when extending behavior.

---

## üìö Dictionary

Key concepts for working with Tasty:

### Style Mapping

Object where keys represent states and values are the styles to apply. Used for state-based styling without conditional logic.

```jsx
fill: { '': '#white', hovered: '#gray.05', 'theme=danger': '#red' }
```

#### State Key Types

State keys support various selector syntaxes, all appended **directly to the element selector** (no space):

| Syntax | Example | Generated CSS |
|--------|---------|---------------|
| Boolean modifier | `hovered` | `[data-hovered]` |
| Value modifier | `theme=danger` | `[data-theme="danger"]` |
| Pseudo-class | `:hover` | `:hover` |
| Class selector | `.active` | `.active` |
| Attribute selector | `[aria-expanded="true"]` | `[aria-expanded="true"]` |
| Combined | `hovered & .active` | `[data-hovered].active` |

**Example:**

```jsx
const Button = tasty({
  styles: {
    fill: {
      '': '#surface',
      '.active': '#primary',           // Same element with .active class
      ':focus-visible': '#purple.10',  // Same element when focused
      'disabled': '#gray.05',          // Same element with data-disabled
    },
  },
});
// .active state generates: .t123.active { ... }
// NOT: .t123 .active { ... } (that would be a descendant)
```

### Sub-element

Element styled using a capitalized key. Identified by `data-element` attribute. Capitalized words in selectors (`:has(Item)`, `> Body > Row`) transform to `[data-element="..."]`.

**Important:** Combinators (`>`, `+`, `~`) must have spaces around them: `:has(Body > Row)` ‚úÖ, not `:has(Body>Row)` ‚ùå. This is a design choice for parser performance.

```jsx
styles: { Title: { preset: 'h3' } }
// Targets: <div data-element="Title">
```

### Compound Sub-elements (`elements` prop)

You can also *declare* sub-elements in the `tasty()` definition via `elements`. This creates compound sub-components (e.g. `ButtonElement.Icon`) that render the correct tag and automatically set `data-element`.

```jsx
const ButtonElement = tasty({
  styles: {
    // Root styles...
    Icon: { color: '#primary' },
    Label: { preset: 't3 strong' },
  },
  elements: {
    Icon: 'span',
    Label: {
      as: 'div',
      qa: 'ButtonLabel', // default data-qa for this sub-element
    },
  },
});

// Usage
<ButtonElement>
  <ButtonElement.Icon />
  <ButtonElement.Label mods={{ emphasized: true }} />
</ButtonElement>
```

**Sub-element component behavior:**
- Always sets `data-element="..."` (based on the key name).
- Supports `qa` / `qaVal` (mapped to `data-qa` / `data-qaval`).
- Supports `mods` (generates `data-*` attributes).
- Supports `isDisabled`, `isHidden`, `isChecked` (mapped to native attributes + `data-*`).
- Supports `tokens` (rendered as inline CSS custom properties; merged with `style`, where `style` has priority).

### Custom Styles

Tasty properties that enhance native CSS with design system integration: `fill` (background), `radius` (border-radius), `border`, `preset` (typography), `gap`.

### Modifier

State value via `mods` prop that generates `data-*` attributes for styling.

```jsx
mods={{ hovered: true, theme: 'danger' }}
// ‚Üí data-hovered="" data-theme="danger"
```

### Color Token

Named color prefixed with `#` that maps to CSS custom properties. Supports opacity with `.N` suffix.

```jsx
fill: '#purple.5'  // ‚Üí var(--purple-color) with 50% opacity
```

### Custom Unit

Shorthand units referencing design system values: `x` (gap), `r` (radius), `bw` (border-width), `fs` (font-size), `sf` (stable grid fractions).

### Style Props

Style properties exposed as direct props via `styleProps` config. Provides cleaner API than using `styles` prop.

### Selector Affix (`$`)

Property controlling combinator for sub-element selectors. Default: descendant (space).

```jsx
Row: { $: '>', padding: '1x' }  // Direct child selector
```

### Tokens

CSS custom properties defined via `tokens` prop, rendered as inline styles. Supports `$name` (regular properties) and `#name` (color properties with RGB variant).

```jsx
tokens={{ $spacing: '2x', '#primary': '#purple' }}
// ‚Üí style="--spacing: calc(2 * var(--gap)); --primary-color: var(--purple-color); --primary-color-rgb: var(--purple-color-rgb)"
```

#### Tokens on Sub-elements

Sub-elements created via `elements` also support `tokens`:

```jsx
const Card = tasty({
  styles: { Title: { color: '#title' } },
  elements: { Title: 'div' },
});

<Card>
  <Card.Title tokens={{ '#title': '#purple' }} />
</Card>
```

### Advanced States (`@` prefix)

State keys with `@` prefix for CSS at-rules and contextual conditions:

| Prefix | Purpose | Example |
|--------|---------|---------|
| `@media` | Media queries | `@media(w < 768px)` |
| `@(...)` | Container queries | `@(panel, w >= 300px)` |
| `@supports` | Feature/selector support queries | `@supports(display: grid)` |
| `@root` | Root element states | `@root(theme=dark)` |
| `@own` | Sub-element's own state | `@own(hovered)` |
| `@starting` | Entry animation | `@starting` (for `@starting-style`) |

---

## üéØ Core Concepts

### Component Creation

Use `tasty()` to create styled components with two main approaches:

```jsx
// 1. Create new element
const Box = tasty({
  as: 'div',
  styles: { /* styles */ },
});

// 2. Extend existing component
const StyledButton = tasty(Button, {
  styles: { /* additional styles */ },
});
```

### Style Props - Direct Style Access

Use `styleProps` to expose style properties as direct component props:

```jsx
const FlexibleBox = tasty({
  as: 'div',
  styles: {
    display: 'flex',
    padding: '2x',
  },
  styleProps: ['gap', 'align', 'placeContent', 'fill'],
});

// Usage - style properties become direct props
<FlexibleBox
  gap="2x"
  align="center"
  placeContent="space-between"
  fill="#surface"
>
  Content
</FlexibleBox>

// Equivalent to using styles prop:
<FlexibleBox styles={{
  gap: '2x',
  align: 'center',
  placeContent: 'space-between',
  fill: '#surface'
}}>
  Content
</FlexibleBox>
```

**Benefits of `styleProps`:**
- **Cleaner API** - No need for `styles` prop wrapper
- **Better TypeScript support** - Props are properly typed
- **Component-specific styling** - Expose only relevant properties
- **State-based styling** - Works with objects: `fill={{ '': '#white', hovered: '#gray' }}`

**Style Prop Priority:**
```jsx
// Direct props override styles prop
<FlexibleBox
  styles={{ gap: '1x' }}
  gap="3x"  // This takes priority
/>

// Both direct props and styles can be used together
<FlexibleBox
  styles={{ padding: '2x', border: true }}
  gap="2x"
  align="center"
/>
```

### Style System Overview

Tasty enhances CSS with:
- **Design tokens** - `#purple`, `#text`, `#border`
- **Custom units** - `2x` (gap), `1r` (radius), `1bw` (border-width)
- **State objects** - `{ '': 'default', hovered: 'hover-state' }`
- **Smart defaults** - `border: true` uses design system values

### Color Tokens & Opacity

```jsx
// Color tokens with opacity
color: '#purple',      // Full opacity
color: '#purple.5',    // 50% opacity
color: '#purple.05',   // 5% opacity

// Color token fallback syntax (supports nesting)
color: '(#primary, #secondary)',                    // Single fallback
fill: '(#surface, (#fallback, #default))',          // Nested fallbacks
'#theme-color': '(#brand, #purple)',                // In definitions

// Color token definition syntax
'#primary': 'rgb(255 120 45)',       // Define custom color variables
'#brand': '#purple',                 // Reference existing color tokens
'#accent': '#purple.5',              // With opacity
'#custom': '#aaffbb',                // Hex colors
'#theme': 'var(--purple-color)',     // CSS custom properties

// Via custom property
'$custom-color': 'rgb(255 128 0)',
```

### Custom Units Reference

| Unit | Description | Example | CSS Output |
|------|-------------|---------|------------|
| `x` | Gap multiplier | `2x` | `calc(var(--gap) * 2)` |
| `r` | Border radius | `1r` | `var(--radius)` |
| `cr` | Card border radius | `1cr` | `var(--card-radius)` |
| `bw` | Border width | `2bw` | `calc(var(--border-width) * 2)` |
| `ow` | Outline width | `1ow` | `var(--outline-width)` |
| `fs` | Font size | `1fs` | `var(--font-size)` |
| `lh` | Line height | `1lh` | `var(--line-height)` |
| `sf` | Stable fraction | `1sf` | `minmax(0, 1fr)` |

> **üí° Grid Tip:** Use `sf` units in `gridColumns` for stable grid fractions that prevent layout collapse:
> ```jsx
> gridColumns="1sf 2sf 1sf"  // equivalent to "minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)"
> ```

---

## üìñ Style Properties Reference

### Layout Properties

#### `display` & `hide`
```jsx
display: 'flex',     // Standard CSS values
display: 'grid',
hide: true,          // Shortcut for display: none
```

#### `flow` - Layout Direction
Unified control for flex and grid direction:
```jsx
// Flex containers (display: flex)
flow: 'row',         // flex-flow: row
flow: 'column wrap', // flex-flow: column wrap
flow: 'row nowrap',  // flex-flow: row nowrap

// Grid containers (display: grid)
flow: 'column',      // grid-auto-flow: column
flow: 'row dense',   // grid-auto-flow: row dense

// Block layout: affects gap direction
// Default: 'row' for flex, 'column' for block
// Requires display prop for proper detection
```

#### `gap` - Element Spacing
Works across all layout types:
```jsx
gap: '2x',           // Standard gap
gap: '1x 2x',        // Row gap, column gap
gap: true,           // Default: '1x'

// Flex/Grid: Uses native CSS gap
// Block: Emulates with margin on children
// Wrap mode: Uses negative margins on container
// Default value (true): '1x' ‚Üí 'var(--gap)'
// Direction depends on flow prop
```

#### `padding` & `margin` - Spacing
Enhanced syntax with directional modifiers:
```jsx
padding: '2x',                    // All sides
padding: '2x 1x',                 // Vertical, horizontal
padding: '2x top',                // Top only
padding: '1x left right',         // Left and right
padding: true,                    // Default: '1x'

// Available modifiers: top, right, bottom, left
// Default value (true): '1x' ‚Üí 'var(--gap)'
// Also supports: paddingBlock, paddingInline for logical properties
```

#### `width` & `height` - Dimensions
```jsx
width: '10x',                     // Fixed width
width: '1x 10x',                  // min-width, max-width
width: '1x 5x 10x',               // min, value, max
width: 'min 2x',                  // min-width only ('var(--gap)' default)
width: 'max 100%',                // max-width only ('100%' default)
width: 'fixed 10x',               // Fixed size (all three equal: min, value, max)
width: 'stretch',                 // Fill available space (browser-specific)

// Default values:
// - Default: 'auto'
// - Min default: 'var(--gap)'
// - Max default: '100%'
// Intrinsic sizing: max-content, min-content, fit-content, stretch
// Modifiers: min, max, fixed
// ‚úÖ Prefer unified syntax over separate maxWidth/minWidth properties
```

### Visual Properties

#### `color` & `fill` - Colors
```jsx
color: '#text',                   // Text color token
color: true,                      // Default: 'currentColor'
fill: '#purple.10',               // Background with opacity
fill: '#surface',                 // Background color token
color: '(#primary, #dark)',       // Color with fallback
fill: '(#surface, (#white, #default))', // Nested fallbacks
color: {
  '': '#dark',
  hovered: '#purple',
  disabled: '#gray',
},

// color default (true): 'currentColor'
// Provides context variables: --current-color, --current-color-rgb
```

#### `image` - Background Images
```jsx
image: 'url(/path/to/image.png)',
image: 'linear-gradient(to right, #purple, #danger)',
// Use with other background props: backgroundSize, backgroundPosition, etc.
```

#### `border` - Borders
Enhanced border syntax with directional support:
```jsx
border: true,                     // Default: '1bw solid var(--border-color)'
border: '2bw solid #purple',      // Custom width, style, color
border: '1bw top',                // Top border only
border: 'dashed #danger left right', // Left/right borders
border: '#purple',                // Color only (uses defaults for width/style)

// Default values:
// - Width: '1bw' ‚Üí 'var(--border-width)'
// - Style: 'solid'
// - Color: 'var(--border-color)'
// Available styles: none, hidden, dotted, dashed, solid, double, groove, ridge, inset, outset
// Available modifiers: top, right, bottom, left
```

#### `radius` - Border Radius
Advanced radius with shapes and directions:
```jsx
radius: '2r',                     // Custom radius
radius: true,                     // Default: '1r' ‚Üí 'var(--radius)'
radius: 'round',                  // Fully rounded (9999rem)
radius: 'ellipse',                // Elliptical (50%)
radius: 'leaf',                   // Asymmetric leaf shape
radius: 'backleaf',               // Reverse leaf shape
radius: '1r top',                 // Top corners only (top-left, top-right)

// Default value (true): '1r' ‚Üí 'var(--radius)'
// Shape modifiers: round, ellipse, leaf, backleaf
// Directional modifiers: top, right, bottom, left
```

### Typography Properties

#### `preset` - Typography Presets
Semantic typography shortcuts:
```jsx
preset: 'h1',                     // Heading 1
preset: 't2',                     // Text style 2
preset: 'p1',                     // Paragraph 1
preset: 'h2 strong',              // Bold heading 2

// Available presets:
// Headings: h1, h2, h3, h4, h5, h6
// Text: t1, t2, t2m, t3, t3m, t4, t4m
// Paragraphs: p1, p2, p3, p4
// Main text: m1, m2, m3
// Captions: c1, c2, tag
```

#### `align`, `justify`, & `place` - Alignment
Unified alignment control for flex and grid:
```jsx
align: 'center',                  // align-items & align-content: center
justify: 'space-between',         // justify-items & justify-content: space-between
place: 'center',                  // place-items & place-content: center

// Sets both *-items and *-content properties
// Works with flex and grid layouts
// Standard CSS alignment values supported
```

#### `inset` - Positioning Offset
Shorthand for positioning offsets:
```jsx
inset: '0',                       // All sides: 0
inset: '2x top',                  // Top only: 2x
inset: '1x left right',           // Left and right: 1x
inset: true,                      // Default: 0

// Available modifiers: top, right, bottom, left
// Default value (true): 0
```

### Advanced Properties

#### `transition` - Animations
Semantic transition names:
```jsx
transition: 'fill 0.2s',          // Background color
transition: 'background 0.2s',    // All background properties
transition: 'fade 0.15s ease-in', // Mask transitions
transition: 'theme 0.3s',         // All theme properties
transition: 'border 0.2s, radius 0.3s', // Multiple properties

// Semantic names: fade, fill, image, background, border, radius, shadow,
// outline, preset, text, theme, width, height, gap, zIndex, filter,
// translate, rotate, scale, placeSelf, mark
// Default timing: 'var(--transition)'
```

#### `scrollbar` - Scrollbar Styling
```jsx
scrollbar: true,                  // Default: 'thin' with system colors
scrollbar: 'thin 10px #purple.40 #dark.04', // Size and colors
scrollbar: 'none',                // Hidden scrollbar
scrollbar: 'auto',                // Browser default width
scrollbar: 'styled 12px #primary #surface', // Enhanced appearance

// Available modifiers:
// - thin, auto, none: scrollbar-width values
// - stable, both-edges: scrollbar-gutter behavior
// - always: force scrollbars to show (sets overflow: scroll)
// - styled: enhanced appearance with transitions
// Color order: thumb, track, corner (optional)
// Default colors: var(--scrollbar-thumb-color), transparent
```

#### `fade` - Edge Fading
Gradient masks for edge fading:
```jsx
fade: true,                       // All edges, default width
fade: '2x left right',            // Left/right edges, 2x width
fade: '1x top',                   // Top edge only
fade: '3x 1x top bottom',         // Different widths per edge

// Default width: 'var(--fade-width)'
// Default edges: top, right, bottom, left (all)
// Available modifiers: top, right, bottom, left
// Uses CSS mask with linear gradients and mask-composite: intersect
```

---

## üîß Advanced Features

### Modifiers & State Binding

Modifiers create `data-*` attributes for state-based styling:

```jsx
const Button = tasty({
  styles: {
    fill: {
      '': '#blue',
      hovered: '#blue.8',          // Custom boolean modifier
      pressed: '#blue.6',          // Custom boolean modifier
      'theme=danger': '#red',      // Value modifier
      'size=large': '#blue.10',    // Value modifier
      disabled: '#gray',           // Built-in state
    },
  },
});

// Usage with boolean mods
<Button mods={{ hovered: true, pressed: false }} disabled>
  Click me
</Button>
// Renders: <button data-hovered="" disabled>

// Usage with value mods
<Button mods={{ theme: 'danger', size: 'large' }}>
  Delete
</Button>
// Renders: <button data-theme="danger" data-size="large">
```

#### Value Modifiers

Modifiers now accept string values in addition to boolean:

```jsx
// Boolean mods
mods={{ hovered: true }}         // ‚Üí data-hovered=""
mods={{ isSelected: true }}      // ‚Üí data-selected="" (preserves 'is' via kebab-case)

// String value mods
mods={{ theme: 'danger' }}       // ‚Üí data-theme="danger"
mods={{ size: 'large' }}         // ‚Üí data-size="large"
mods={{ variant: 'primary' }}    // ‚Üí data-variant="primary"

// Number mods (converted to string)
mods={{ level: 2 }}              // ‚Üí data-level="2"

// Empty string (explicit empty value)
mods={{ label: '' }}             // ‚Üí data-label=""

// Mixed boolean and value mods
mods={{ 
  hovered: true, 
  theme: 'danger',
  size: 'large'
}}
// ‚Üí data-hovered="" data-theme="danger" data-size="large"
```

#### Shorthand Syntax for Value Mods

Use shorthand syntax in style definitions for value mods:

```jsx
const Button = tasty({
  styles: {
    fill: {
      '': '#surface',
      // Recommended shorthand (unquoted values)
      'theme=danger': '#red',
      'theme=warning': '#yellow',
      'size=large': '#blue.10',
      
      // Also supported (quoted values)
      'variant="primary"': '#purple',
      "variant='secondary'": '#gray',
      
      // Full attribute selector (pass-through)
      '[data-theme="danger"]': '#red',
      
      // Combining with boolean mods
      'hovered & theme=danger': '#light-red',
      'theme=danger & size=large': '#dark-red',
    },
  },
});
```

### Complex State Logic

Use logical operators for complex state combinations:

#### Operators & Precedence

State keys (for both regular modifiers and advanced `@...` states) support boolean logic with a predictable precedence (highest ‚Üí lowest):

- `!` (NOT)
- `^` (XOR)
- `|` (OR)
- `&` (AND)

Use parentheses to group: `(@mobile | @tablet) & !disabled`.

```jsx
color: {
  '': '#default',
  '!disabled & hovered': '#blue',     // NOT disabled AND hovered
  'success | complete': '#green',     // success OR complete
  ':hover': '#purple',                // CSS pseudo-class
  '.active': '#green',                // CSS class selector (same element)
  'theme=dark': '#light',             // Value modifier (recommended)
  'theme="special dark"': '#purple',  // Value modifier with spaces (recommended)
  '[aria-expanded="true"]': '#green', // Attribute selector (escape hatch)
}
```

> **üí° Class Selector Note:** When using `.class` in state keys, it's appended directly to the element selector without a space, targeting the **same element** (e.g., `.tasty-class.active`). This is different from sub-element keys at the style root, which create descendant selectors.

### Advanced States

Advanced states are state keys that start with `@...`. Unlike regular modifiers (which become `data-*` selectors on the component), advanced states compile into **CSS at-rules** (like `@media`, `@container`), a **root prefix** (`:root...`), or special wrappers (like `@starting-style`).

You can use them anywhere a normal state key is used (including inside sub-elements) and combine them with logical operators.

#### Predefined State Aliases (recommended)

If you repeat the same advanced state in many places, define an alias once and reuse it. You can define aliases globally via `configure({ states })`, or locally per component via `tasty({ states: { ... } })`.

```jsx
import { configure, tasty } from '@cube-dev/ui-kit';

configure({
  states: {
    '@mobile': '@media(w < 768px)',
    '@dark': '@root(theme=dark)',
  },
});

const Card = tasty({
  styles: {
    padding: {
      '': '4x',
      '@mobile': '3x',
      '@dark & @mobile': '2x',
    },
  },
});
```

#### Media Queries (`@media`)

```jsx
styles: {
  gridColumns: {
    '': '1fr 1fr 1fr',              // Default: 3 columns
    '@media(w <= 1200px)': '1fr 1fr', // ‚â§1200px: 2 columns
    '@media(w <= 768px)': '1fr',      // ‚â§768px: 1 column
  },
  padding: {
    '': '4x',
    '@media(h > 800px)': '6x',        // Height query
    '@media:print': '2x',             // Media type
  },
}
// Shorthands: w=width, h=height. Range syntax: <=, <, >=, >, 600px <= w < 900px
```

#### Container Queries (`@(...)`)

Container queries require a container. In CSS terms, that means setting `container-type` and optionally `container-name` on some ancestor element. Prefer using the native `container` shorthand:

- `container: 'card / inline-size'` (equivalent to `container-name: card; container-type: inline-size;`)

```jsx
styles: {
  flow: {
    '': 'column',
    '@(w >= 400px)': 'row',                    // Unnamed container
    '@(panel, w >= 300px)': 'row',             // Named container "panel"
  },
  fill: {
    '': '#surface',
    '@(sidebar, $variant=danger)': '#red.05',  // Style query (CSS: style(--variant: "danger"))
  },
}
```

**Style queries inside `@(...)`:**

- `$name` ‚Üí checks for existence of `--name` (`style(--name)`)
- `$name=value` ‚Üí checks equality (`style(--name: "value")`)

```jsx
const Container = tasty({
  styles: {
    container: 'card / inline-size',
  },
});

const Child = tasty({
  styles: {
    padding: {
      '': '4x',
      '@(card, w < 400px)': '2x',
      '@(card, $variant)': '3x',           // when --variant exists
      '@(card, $variant=danger)': '1x',    // when --variant equals "danger"
    },
  },
});
```

#### Supports Queries (`@supports`)

Use `@supports(...)` to **check support and then use the feature**. For example, masonry is landing as `display: grid-lanes` (with `display: grid` as a safe fallback). See: [Masonry Layout is Now `grid-lanes`](https://css-tricks.com/masonry-layout-is-now-grid-lanes/).

```jsx
styles: {
  display: {
    '': 'grid',
    '@supports(display: grid-lanes)': 'grid-lanes',
  },
}
```

**Selector support**

To check selector support (e.g. `:has()`), use `@supports($, <selector>)`. It compiles to `@supports selector(<selector>)`:

```jsx
styles: {
  border: {
    '': '1bw solid #border',
    '@supports($, :has(*)) & :has(> Icon)': '2bw solid #purple',
  },
}
```

#### Root States (`@root`)

Style based on document root attributes (theme, mode, etc.):

```jsx
styles: {
  fill: {
    '': '#white',
    '@root(theme=dark)': '#dark-02',      // :root[data-theme="dark"]
    '@root(.high-contrast)': '#black',    // :root.high-contrast
    '@root([data-density="compact"])': '#gray', // Attribute selector
  },
}
```

`@root(...)` accepts:

- `key=value` ‚Üí `:root[data-key="value"]` (kebab-cased)
- `camelCaseFlag` ‚Üí `:root[data-camel-case-flag]`
- `.className` ‚Üí `:root.className`
- `[attr]` / `[attr="value"]` ‚Üí `:root[...]`

#### Own States (`@own`)

Apply a sub-element‚Äôs **own** state (not the parent‚Äôs). This only makes sense inside a sub-element style block (Tasty will warn if you use `@own(...)` at the root level, where it‚Äôs equivalent to the inner condition).

```jsx
styles: {
  Icon: {
    color: {
      '': '#gray',
      '@own(hovered)': '#purple',         // Icon's own hover state
      'disabled': '#light-gray',          // Parent's disabled state
    },
  },
}
```

#### Starting Style (`@starting`)

Entry animations with `@starting-style`:

```jsx
styles: {
  opacity: {
    '': 1,
    '@starting': 0,                       // Start at 0, animate to 1
  },
  transform: {
    '': 'translateY(0)',
    '@starting': 'translateY(-10px)',
  },
  transition: 'opacity 0.3s, transform 0.3s',
}
```

#### Combining Advanced States

```jsx
styles: {
  padding: {
    '': '4x',
    '@media(w < 600px) & hovered': '3x',   // Media + modifier
    '@root(theme=dark) & disabled': '2x',  // Root + modifier
  },
}
```

> **üí° Tips:**
> - Use `&` to combine states, `|` for alternatives, `!` for negation, `^` for XOR.
> - OR (`|`) is **ordered**: the first matching branch wins (Tasty makes branches exclusive to avoid overlap).
> - In state maps, place **more specific keys later** so they win over earlier ones.

> **‚ö†Ô∏è Important:** Place more specific rules last - they take precedence.

### Sub-element Styling

Style inner elements using `data-element` attributes:

```jsx
const Card = tasty({
  styles: {
    padding: '4x',

    // Sub-element styles
    Title: {                      // Styles data-element="Title"
      preset: 'h3',
      color: '#primary',
    },
    Content: {                    // Styles data-element="Content"
      color: {
        '': '#text',
        '[data-variant="danger"]': '#danger',
      },
    },
  },
});

// Usage
<Card>
  <div data-element="Title">Card Title</div>
  <div data-element="Content">Card content</div>
</Card>
```

#### Selector Affix (`$`)

Control sub-element selector combinator using the `$` property:

```jsx
const Table = tasty({
  styles: {
    // Direct child selector
    Row: {
      $: '>',                     // .table > [data-element="Row"]
      padding: '1x',
    },
    
    // Chained selectors (auto-transforms capitalized words)
    // ‚ö†Ô∏è Important: Spaces required around combinators for parsing
    Cell: {
      $: '> Body > Row >',        // ‚úÖ Correct: spaces around > 
                                  // ‚ùå Wrong: '>Body>Row>' (parser can't split)
                                  // ‚Üí .table > [data-element="Body"] > [data-element="Row"] > [data-element="Cell"]
      border: '1bw solid #border',
    },
    
    // Default: descendant selector (space)
    Text: {
      color: '#text',             // .table [data-element="Text"]
    },
  },
});
```

> **‚ö†Ô∏è Space Requirements:** Combinators (`>`, `+`, `~`) in selector affixes **must have spaces** around them when used with capitalized element names. Use `$: '> Body > Row'` ‚úÖ, not `$: '>Body>Row'` ‚ùå. This is a performance consideration‚Äîthe parser uses simple whitespace splitting to identify element names.

#### `:has()` Selector with Sub-elements

Style components based on their children using the `:has()` pseudo-class:

```jsx
const List = tasty({
  styles: {
    border: {
      '': 'none',
      // ‚ö†Ô∏è Spaces required around combinators (>, +, ~)
      ':has(Body > Row)': '1bw solid #border',  // ‚úÖ Correct
      // ':has(Body>Row)': ...                   // ‚ùå Wrong: parser can't split
    },
    
    padding: {
      '': '2x',
      ':has(Item)': '4x',                       // Single element, no combinator
      'hovered & :has(Item)': '6x',             // Combining with other modifiers
    },
  },
});
```

> **‚ö†Ô∏è Space Requirements:** Combinators (`>`, `+`, `~`) **must have spaces** around them when used with capitalized element names. Use `:has(Body > Row)` ‚úÖ, not `:has(Body>Row)` ‚ùå. This is a performance consideration‚Äîthe parser uses whitespace splitting to identify element names. A console error will warn if spaces are missing.

### Keyframes

Define CSS `@keyframes` animations directly in styles:

```jsx
const Pulse = tasty({
  styles: {
    animation: 'pulse 2s infinite',
    '@keyframes': {
      pulse: {
        '0%, 100%': 'transform: scale(1);',
        '50%': 'transform: scale(1.05);',
      },
    },
  },
});
```

Global keyframes via `configure()`:

```jsx
configure({
  keyframes: {
    fadeIn: { from: 'opacity: 0;', to: 'opacity: 1;' },
  },
});
```

Local `@keyframes` override global ones with the same name. Only animations referenced in styles are injected.

#### Keyframes with Media Queries

Combine `@keyframes` with media states for accessibility:

```jsx
const Spinner = tasty({
  styles: {
    animation: {
      '': 'spin 1s infinite linear',
      '@media(prefers-reduced-motion)': 'none',
    },
    '@keyframes': {
      spin: {
        '0%': 'transform: rotate(0deg);',
        '100%': 'transform: rotate(360deg);',
      },
    },
  },
});
```

### Variants & Theming

Create themed component variations:

```jsx
const Button = tasty({
  styles: {
    padding: '2x 4x',
    border: true,
  },
  variants: {
    default: {
      fill: '#blue',
      color: '#white',
    },
    danger: {
      fill: '#red',
      color: '#white',
    },
    outline: {
      fill: 'transparent',
      color: '#blue',
      border: '1bw solid #blue',
    },
  },
});

// Usage
<Button variant="danger">Delete</Button>
<Button variant="outline">Cancel</Button>
```

### Custom Properties

Define and use custom CSS properties:

```jsx
const Component = tasty({
  styles: {
    // Define custom properties
    '$local-spacing': '2x',
    '$theme-color': 'rgb(255 128 0)',

    // Use custom properties
    padding: '$local-spacing',
    color: '$theme-color',
    margin: '($custom-margin, 1x)', // With fallback
  },
});
```

#### Math with Custom Properties

Use parentheses for math expressions with custom properties. Tasty auto-wraps in `calc()`:

```jsx
const Component = tasty({
  styles: {
    // ‚úÖ Correct: tasty syntax with parentheses
    padding: '(1 / 10 * $size)',
    width: '($base-width + 2x)',
    
    // ‚ùå Avoid: raw CSS calc() - use tasty syntax instead
    // padding: 'calc(1 / 10 * var(--size))',
  },
});

// Pass dynamic values via tokens prop
<Component tokens={{ '$size': '100px' }} />
```

### Custom Color Definitions

Define custom color variables with enhanced syntax:

```jsx
const ThemedComponent = tasty({
  styles: {
    // Define custom color variables (maps to --name-color CSS properties)
    '#primary': 'rgb(255 120 45)',       // Creates --primary-color
    '#secondary': '#purple',             // Creates --secondary-color, references purple token
    '#accent': '#purple.5',              // Creates --accent-color with 50% opacity
    '#success': '#aaffbb',               // Creates --success-color from hex
    '#brand': 'var(--purple-color)',     // Creates --brand-color from CSS variable
    '#theme': '(#brand, #purple)',       // Creates --theme-color with fallback chain
    
    // Use the defined colors
    fill: '#primary',                    // Uses var(--primary-color)
    color: '#secondary',                 // Uses var(--secondary-color)  
    border: '1bw solid #accent',         // Uses var(--accent-color)
    
    // Color definitions work with state styling
    '#interactive': {
      '': '#primary',
      'hovered': '#primary.8',
      'pressed': '#primary.6',
    },
  },
});

// Color variables are automatically scoped and provide RGB variants
// Generates: --primary-color, --primary-color-rgb, etc.
// Fallback chains maintain RGB variants: var(--brand-color-rgb, var(--purple-color-rgb))
```

### Tokens Prop - Dynamic CSS Custom Properties

The `tokens` prop allows you to set CSS custom properties as inline styles with design token processing. Unlike `styles` which generates CSS classes, `tokens` are rendered directly as inline styles.

```jsx
// Define component with default tokens
const Card = tasty({
  tokens: { $spacing: '2x', $size: '10x' },
  styles: {
    padding: '$spacing',
    width: '$size',
  },
});

// Usage - tokens become inline CSS custom properties
<Card />
// Renders: <div style="--spacing: calc(2 * var(--gap)); --size: calc(10 * var(--gap))">

// Override tokens at usage
<Card tokens={{ $spacing: '4x' }} />
// Renders: <div style="--spacing: calc(4 * var(--gap)); --size: calc(10 * var(--gap))">

// Add new tokens
<Card tokens={{ $spacing: '4x', '#accent': '#purple' }} />
// Renders: <div style="--spacing: ...; --size: ...; --accent-color: var(--purple-color); --accent-color-rgb: var(--purple-color-rgb)">
```

#### Token Types

| Prefix | Output | Example |
|--------|--------|---------|
| `$name` | `--name` | `$spacing: '2x'` ‚Üí `--spacing: calc(2 * var(--gap))` |
| `#name` | `--name-color` + `--name-color-rgb` | `#accent: '#purple'` ‚Üí `--accent-color: var(--purple-color)` |

#### Key Differences from `styles`

| Feature | `styles` | `tokens` |
|---------|----------|----------|
| Output | CSS classes | Inline styles |
| State mapping | ‚úÖ Supported | ‚ùå Not supported |
| Responsive arrays | ‚úÖ Supported | ‚ùå Not supported |
| Performance | Cached & deduplicated | Per-instance |
| Use case | Static styling | Dynamic values |

#### Merging Priority

Tokens are merged in order (later overrides earlier):
1. Default tokens (from `tasty({ tokens: {...} })`)
2. Instance tokens (from `<Component tokens={{...}} />`)
3. Instance `style` prop (from `<Component style={{...}} />`)

```jsx
const Card = tasty({
  tokens: { $spacing: '1x' },
});

// Instance tokens override defaults
<Card tokens={{ $spacing: '4x' }} />

// style prop overrides everything (not recommended - see warning below)
<Card tokens={{ $spacing: '4x' }} style={{ '--spacing': '100px' }} />
// --spacing will be '100px'
```

> **‚ö†Ô∏è Warning:** Using the `style` prop directly is **not recommended** for general styling. It should only be used in rare cases when you need to spread raw styles from a third-party library to an element. For all other cases, use `tokens` or `styles` props instead.

#### Valid Token Values

- **String** - Processed through tasty parser (`'2x'` ‚Üí `calc(2 * var(--gap))`)
- **Number** - Converted to string (`42` ‚Üí `'42'`); `0` stays as `'0'`
- **undefined/null** - Silently skipped (no CSS property output)

```jsx
// ‚úÖ Valid
tokens={{ $spacing: '2x', $size: 100, $zero: 0 }}

// ‚ùå Invalid - object values not allowed (no state mapping)
tokens={{ $spacing: { '': '1x', hovered: '2x' } }}
// Will log warning and skip this token
```

#### Use Cases

```jsx
// Dynamic theming
const ThemedCard = tasty({
  tokens: { '#card-bg': '#surface', '#card-border': '#border' },
  styles: {
    fill: '#card-bg',
    border: '1bw solid #card-border',
  },
});

// Override theme per-instance
<ThemedCard tokens={{ '#card-bg': '#purple.05', '#card-border': '#purple' }} />

// Dynamic sizing based on props
function DynamicComponent({ columns }) {
  return <Grid tokens={{ $columns: columns }} />;
}

// Responsive values via parent CSS
const Parent = tasty({
  styles: {
    '--child-spacing': ['4x', '2x', '1x'], // Responsive in styles
  },
});
const Child = tasty({
  styles: {
    padding: '$child-spacing', // References parent's responsive property
  },
});
```

## ‚úÖ Best Practices & Anti-patterns

### Do's ‚úÖ

```jsx
// ‚úÖ Use styled wrappers instead of styles prop
const StyledButton = tasty(Button, {
  styles: { fill: '#purple' },
  styleProps: ['fill', 'color'], // Expose common styles as props
});

// ‚úÖ Use design tokens and custom units
styles: {
  color: '#text',
  padding: '2x',
  radius: '1r',
}

// ‚úÖ Define custom color tokens with #name syntax
styles: {
  '#primary': 'rgb(255 120 45)',
  '#accent': '#purple.5',
  fill: '#primary',
  border: '1bw solid #accent',
}

// ‚úÖ Use semantic transition names
transition: 'theme 0.3s'

// ‚úÖ Use sub-element styling for inner elements
styles: {
  Title: { preset: 'h3' },
  Content: { color: '#text' },
}

// ‚úÖ Use modifiers for state-based styling
styles: {
  fill: {
    '': '#white',
    hovered: '#gray.05',
  },
}

// ‚úÖ Use simplified mods for built-in states (disabled, checked, selected)
styles: {
  color: {
    '': '#dark',
    disabled: '#gray',     // Preferred over '[disabled]'
    checked: '#blue',      // Preferred over '[checked]'
    selected: '#purple',   // Preferred over '[selected]'
  },
}

// ‚úÖ Use styleProps for component APIs
const Container = tasty({
  styles: { display: 'flex' },
  styleProps: ['gap', 'padding', 'align', 'justify'],
});
// Enables: <Container gap="2x" align="center" />
```

### Don'ts ‚ùå

```jsx
// ‚ùå Don't use styles prop directly
<Button styles={{ fill: '#purple' }}>Click</Button>

// ‚ùå Don't use raw CSS values when tokens exist
styles: {
  color: '#333333',        // Use '#text' instead
  padding: '16px',         // Use '2x' instead
  radius: '6px',     // Use 'radius: "1r"' instead
}

// ‚ùå Don't use CSS property names when Tasty alternatives exist
styles: {
  backgroundColor: '#blue',   // Use 'fill' instead
  borderColor: '#purple',     // Use 'border' instead
  borderWidth: '2px',         // Use 'border' instead
  borderStyle: 'dashed',      // Use 'border' instead
  borderRadius: '8px',        // Use 'radius' instead
  maxWidth: '100%',           // Use 'width: "max 100%"' instead
  minWidth: '200px',          // Use 'width: "min 200px"' instead
  maxHeight: '500px',         // Use 'height: "max 500px"' instead
  minHeight: '100px',         // Use 'height: "min 100px"' instead
}

// ‚ùå Don't use custom selectors unnecessarily
styles: {
  '& > div': { margin: '1x' },     // Use sub-elements instead
  '&:hover': { color: '#blue' },   // Use modifiers instead
}

// ‚ùå Don't change styles prop at runtime (performance)
const [dynamicStyles, setDynamicStyles] = useState({});
<Component styles={dynamicStyles} /> // Use tokens prop for dynamic values

// ‚ùå Don't use style prop for custom styling
<Component style={{ padding: '20px' }} /> // Only for spreading third-party library styles
```

#### Tasty vs Native CSS Properties

| ‚ùå Native CSS | ‚úÖ Tasty Alternative | Benefits |
|---------------|---------------------|----------|
| `backgroundColor` | `fill` | Color tokens, context variables |
| `borderColor`, `borderWidth`, `borderStyle` | `border` | Unified syntax, directional modifiers |
| `borderRadius` | `radius` | Custom units, shape modifiers |
| `maxWidth` | `width: "max 100%"` | Unified dimension control |
| `minWidth` | `width: "min 200px"` | Consistent syntax |
| `maxHeight` | `height: "max 500px"` | Dimension constraints |
| `minHeight` | `height: "min 100px"` | Design system integration |

```jsx
// ‚úÖ Recommended Tasty approach
styles: {
  fill: '#surface',
  border: '1bw solid #border',
  radius: '1r',
  width: 'min 200px max 800px',
  height: 'min 100px',
}
```

### Performance Tips ‚ö°

```jsx
// ‚úÖ Use tokens prop for dynamic CSS custom properties
<Component
  tokens={{ $sidePadding: dynamicPadding }}
  styles={{ padding: '1x $sidePadding' }}
/>

// ‚ö†Ô∏è Avoid using style prop (only for spreading third-party library styles)
// ‚ùå Don't do this for custom styling:
<Component style={{ '--side-padding': dynamicPadding }} />

// ‚úÖ Avoid changing styles prop at runtime
// ‚ùå Don't do this:
<Component styles={isActive ? activeStyles : defaultStyles} />

// ‚úÖ Use modifiers instead:
<Component mods={{ active: isActive }} />

// ‚úÖ Use variants for theme switching instead of dynamic styles
<Component variant={isDark ? 'dark' : 'light'} />
```

### Common Patterns üé®

```jsx
// Interactive card with hover states
const InteractiveCard = tasty({
  styles: {
    padding: '4x',
    fill: {
      '': '#surface',
      hovered: '#surface-hover',
    },
    border: '1bw solid #border',
    radius: '2r',
    transition: 'fill 0.2s',
  },
});

// Button with variants
const Button = tasty({
  styles: {
    padding: '2x 4x',
    radius: '1r',
    border: 'none',
    preset: 't3',
    transition: 'fill 0.2s',
  },
  variants: {
    primary: { fill: '#primary', color: '#white' },
    secondary: { fill: '#secondary', color: '#text' },
    ghost: { fill: 'transparent', color: '#primary' },
  },
});
```

---

## ü™ù Hooks

Tasty provides React hooks for programmatic style handling when you need more control over style injection.

### useStyles

The `useStyles` hook generates and injects styles for a given tasty styles object, returning a className to apply to your element.

```tsx
import { useStyles } from '@cube-dev/ui-kit';

function MyComponent() {
  const { className } = useStyles({
    padding: '2x',
    fill: '#surface',
    radius: '1r',
    border: '1bw solid #border',
  });

  return <div className={className}>Styled content</div>;
}
```

**When to use `useStyles`:**
- Building custom components that need dynamic className generation
- Integrating with third-party libraries that expect className strings
- Creating utility hooks that compose styles

**Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `styles` | `Styles \| undefined` | Tasty styles object (same format as `tasty()`) |

**Returns:**

| Property | Type | Description |
|----------|------|-------------|
| `className` | `string` | Generated CSS class name to apply to element |

### useGlobalStyles

The `useGlobalStyles` hook injects styles for a CSS selector globally, without generating classNames. Useful for styling elements by selector.

```tsx
import { useGlobalStyles } from '@cube-dev/ui-kit';

function ThemeStyles() {
  useGlobalStyles('.card', {
    padding: '4x',
    fill: '#surface',
    radius: '1r',
    border: '1bw solid #border',
  });

  return null;
}

// Usage
function App() {
  return (
    <>
      <ThemeStyles />
      <div className="card">This card is styled globally</div>
    </>
  );
}
```

**When to use `useGlobalStyles`:**
- Styling third-party components by their CSS classes
- Creating theme overrides for existing selectors
- Adding styles to elements you don't control directly
- Conditional global styling (styles inject/cleanup with component lifecycle)

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `selector` | `string` | CSS selector to apply styles to (e.g., `.card`, `[data-theme="dark"]`) |
| `styles` | `Styles` | Tasty styles object (same format as `tasty()`) |

**Features:**
- Supports all tasty style syntax including state-based styles, sub-elements, and advanced states
- Styles are automatically cleaned up when the component unmounts
- Works with complex selectors: `.parent > .child`, `button[data-variant="primary"]`, etc.

```tsx
// State-based global styles
useGlobalStyles('.interactive-card', {
  fill: {
    '': '#surface',
    ':hover': '#surface-hover',
    ':focus': '#surface-focus',
  },
  transition: 'fill 0.2s',
});

// Sub-element styles
useGlobalStyles('.data-table', {
  border: '1bw solid #border',
  Header: {
    fill: '#surface-alt',
    preset: 't3 strong',
  },
  Row: {
    $: '>',
    border: '1bw solid #border bottom',
  },
});
```

### useRawCSS

The `useRawCSS` hook injects **plain CSS text** (without tasty parsing). It‚Äôs useful for global resets, importing third‚Äëparty snippets, or when you already have authored CSS and just need lifecycle-managed injection/cleanup.

Supports two overloads:
- **Static CSS**: `useRawCSS(cssString, options?)`
- **Factory function**: `useRawCSS(() => cssString, deps, options?)` (re-evaluates when deps change, like `useMemo`)

```tsx
import { useRawCSS } from '@cube-dev/ui-kit';

// Static CSS
function GlobalReset() {
  useRawCSS(`
    body { margin: 0; padding: 0; }
  `);

  return null;
}

// Dynamic CSS (factory + deps)
function ThemeCSS({ theme }: { theme: 'dark' | 'light' }) {
  useRawCSS(
    () => `
      :root {
        --app-bg: ${theme === 'dark' ? '#111' : '#fff'};
        --app-text: ${theme === 'dark' ? '#fff' : '#111'};
      }
    `,
    [theme],
  );

  return null;
}
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `root` | `Document \| ShadowRoot` | Where to inject the `<style>` tag (defaults to `document`) |

---

## üîó Cross-References

- **Getting Started**: See [Quick Start](#-quick-start) for basic usage patterns
- **Layout**: See [Layout Properties](#layout-properties) for `flow`, `gap`, `padding`, `margin`
- **Styling**: See [Visual Properties](#visual-properties) for `color`, `fill`, `border`, `radius`
- **Typography**: See [Typography Properties](#typography-properties) for `preset` and text styling
- **Interactivity**: See [Modifiers & State Binding](#modifiers--state-binding) for hover, focus, and custom states
- **Theming**: See [Variants & Theming](#variants--theming) for component variations
- **Performance**: See [Performance Tips](#performance-tips-) for optimization techniques
- **Hooks**: See [Hooks](#-hooks) for `useStyles`, `useGlobalStyles`, and `useRawCSS`
- **Create Component Guide**: See [CreateComponent.docs.mdx](/docs/tasty-create-component--docs) for component creation patterns

---

> **Need Help?** This documentation covers the most important `tasty` features. For additional examples and component creation patterns, see the [Component Creation Guide](/docs/tasty-create-component--docs).
