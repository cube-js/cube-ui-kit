import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="tasty/Style Injector" />

# Tasty Style Injector

A high-performance CSS-in-JS solution that powers the Tasty design system with efficient style injection, automatic cleanup, and first-class SSR support.

---

## 🚀 Overview

The Style Injector is the core engine behind Tasty's styling system, providing:

- **🔄 Hash-based deduplication** - Identical CSS gets the same className
- **📊 Reference counting** - Automatic cleanup when components unmount
- **🎯 CSS nesting flattening** - Handles `&`, `.Class`, `SubElement` patterns
- **🎬 Keyframes injection** - First-class `@keyframes` support with deduplication
- **🧹 Safe bulk cleanup** - Unused styles are aged and cleaned up in partial batches
- **🖥️ SSR support** - Deterministic class names and CSS extraction
- **🌙 Multiple roots** - Works with Document and ShadowRoot
- **🔒 DOM presence validation** - Prevents deletion of styles still active in DOM

> **💡 Note:** This is internal infrastructure that powers Tasty components. Most developers will interact with the higher-level `tasty()` API instead.

---

## 🏗️ Architecture

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   tasty()       │────│  Style Injector  │────│  Sheet Manager  │
│   components    │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                        │                       │
         │                        │                       │
         ▼                        ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Style Results  │    │ Keyframes Manager│    │  Root Registry  │
│  (CSS rules)    │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                                            │
         │                                            │
         ▼                                            ▼
┌─────────────────┐                             ┌─────────────────┐
│   Hash Cache    │                             │ <style> elements│
│   Deduplication │                             │ CSSStyleSheet   │
└─────────────────┘                             └─────────────────┘
```

---

## 📖 Core API

### `inject(rules, options?): InjectResult`

Injects CSS rules and returns a className with dispose function.

```typescript
import { inject } from '@cube-dev/ui-kit/tasty/injector';

// Component styling - generates tasty class names
const result = inject([{
  selector: '.t-abc123',
  declarations: 'color: red; padding: 10px;',
}]);

console.log(result.className); // 't-abc123'

// Cleanup when component unmounts
result.dispose();
```

### `injectGlobal(rules, options?): { dispose: () => void }`

Injects global styles that don't reserve tasty class names.

```typescript
// Global styles - for body, resets, etc.
const globalResult = injectGlobal([
  {
    selector: 'body',
    declarations: 'margin: 0; font-family: Arial;',
  },
  {
    selector: '.header',
    declarations: 'background: blue; color: white;',
    atRules: ['@media (min-width: 768px)'],
  }
]);

// Only returns dispose function - no className needed for global styles
globalResult.dispose();
```

### `keyframes(steps, nameOrOptions?): KeyframesResult`

Injects CSS keyframes with automatic deduplication.

```typescript
// Generated name (k0, k1, k2...)
const fadeIn = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 },
});

// Custom name
const slideIn = keyframes({
  '0%': 'transform: translateX(-100%)',
  '100%': 'transform: translateX(0)',
}, 'slideInAnimation');

// Use in styles
const animatedComponent = inject([{
  selector: '.t-animated',
  declarations: `animation: ${fadeIn} 300ms ease-in;`
}]);

// Cleanup
fadeIn.dispose();
animatedComponent.dispose();
```

### `configure(config): void`

Configures the global injector instance.

```typescript
configure({
  devMode: true,                     // Enable development features
  maxRulesPerSheet: 8000,            // Cap rules per stylesheet
  unusedStylesThreshold: 500,        // Trigger cleanup threshold
  bulkCleanupDelay: 5000,            // Cleanup delay (ms)
  idleCleanup: true,                 // Use requestIdleCallback
  bulkCleanupBatchRatio: 0.5,        // Clean up oldest 50%
  unusedStylesMinAgeMs: 10000,       // Minimum age before cleanup
  forceTextInjection: false,         // Force textContent insertion
  nonce: 'csp-nonce',                // CSP nonce for security
});
```

---

## 🔧 Advanced Features

### Style Result Format

The injector works with `StyleResult` objects from the tasty parser:

```typescript
interface StyleResult {
  selector: string;              // CSS selector
  declarations: string;          // CSS declarations
  atRules?: string[];           // @media, @supports, etc.
  nestingLevel?: number;        // Nesting depth for specificity
}

// Example StyleResult
const styleRule: StyleResult = {
  selector: '.t-button',
  declarations: 'padding: 8px 16px; background: blue; color: white;',
  atRules: ['@media (min-width: 768px)'],
  nestingLevel: 0,
};
```

### Deduplication & Performance

```typescript
// Identical CSS rules get the same className
const button1 = inject([{
  selector: '.t-btn1',
  declarations: 'padding: 8px; color: red;'
}]);

const button2 = inject([{
  selector: '.t-btn2', 
  declarations: 'padding: 8px; color: red;' // Same declarations
}]);

// Both get the same className due to deduplication
console.log(button1.className === button2.className); // true
```

### Reference Counting

```typescript
// Multiple components using the same styles
const comp1 = inject([commonStyle]);
const comp2 = inject([commonStyle]);
const comp3 = inject([commonStyle]);

// Style is kept alive while any component uses it
comp1.dispose(); // refCount: 3 → 2
comp2.dispose(); // refCount: 2 → 1
comp3.dispose(); // refCount: 1 → 0, marked for cleanup
```

### Bulk Cleanup System

```typescript
// Styles are not immediately deleted when dispose() is called
// Instead, they're marked as unused and cleaned up in batches

configure({
  unusedStylesThreshold: 100,    // Cleanup when 100+ unused styles
  bulkCleanupBatchRatio: 0.3,    // Remove oldest 30% each time
  unusedStylesMinAgeMs: 5000,    // Styles must be unused for 5s
});

// This prevents performance issues from frequent DOM manipulation
// and allows "recently used" styles to be quickly reactivated
```

### Shadow DOM Support

```typescript
// Works with Shadow DOM
const shadowRoot = document.createElement('div').attachShadow({ mode: 'open' });

const shadowStyles = inject([{
  selector: '.shadow-component',
  declarations: 'color: purple;'
}], { root: shadowRoot });

// Keyframes in Shadow DOM
const shadowAnimation = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
}, { root: shadowRoot, name: 'shadowFade' });
```

---

## 🎭 SSR & Testing

### Server-Side Rendering

```typescript
// Extract CSS for SSR
const cssText = getCssText();

// Extract CSS for specific DOM subtree (like jest-styled-components)
const container = render(<MyComponent />);
const componentCSS = getCssTextForNode(container);
```

### Test Environment Detection

```typescript
// Automatically detected test environments:
// - NODE_ENV === 'test'
// - Jest globals (describe, it, expect)
// - jsdom user agent
// - Vitest, Mocha globals

const isTest = getIsTestEnvironment();

// Test-specific optimizations:
configure({
  forceTextInjection: isTest,  // More reliable in test environments
  devMode: true,               // Always enable dev features in tests
});
```

### Memory Management in Tests

```typescript
// Clean up between tests
afterEach(() => {
  cleanup(); // Force cleanup of unused styles
});

// Full cleanup after test suite
afterAll(() => {
  destroy(); // Destroy all stylesheets and reset state
});
```

---

## 📊 Development Features

### Performance Metrics

When `devMode` is enabled, the injector tracks comprehensive metrics:

```typescript
configure({ devMode: true });

// Access metrics through the global injector
const metrics = injector.instance.getMetrics();

console.log({
  cacheHits: metrics.hits,           // Successful cache hits
  cacheMisses: metrics.misses,       // New styles injected
  unusedHits: metrics.unusedHits,    // Reactivated unused styles
  bulkCleanups: metrics.bulkCleanups, // Cleanup operations
  stylesCleanedUp: metrics.stylesCleanedUp, // Total styles removed
  totalInsertions: metrics.totalInsertions, // Lifetime insertions
});
```

### Debug Information

```typescript
// Get detailed information about injected styles
const debugInfo = injector.instance.getDebugInfo();

console.log({
  activeStyles: debugInfo.activeStyles,     // Currently active styles
  unusedStyles: debugInfo.unusedStyles,     // Styles marked for cleanup
  totalSheets: debugInfo.totalSheets,       // Number of stylesheets
  totalRules: debugInfo.totalRules,         // Total CSS rules
});
```

### Cleanup History

```typescript
// Track cleanup operations over time
const metrics = injector.instance.getMetrics();

metrics.cleanupHistory.forEach(cleanup => {
  console.log({
    timestamp: new Date(cleanup.timestamp),
    classesDeleted: cleanup.classesDeleted,
    rulesDeleted: cleanup.rulesDeleted,
    cssSize: cleanup.cssSize,
  });
});
```

---

## ⚡ Performance Optimizations

### Best Practices

```typescript
// ✅ Reuse styles - identical CSS gets deduplicated
const buttonBase = { padding: '8px 16px', borderRadius: '4px' };

// ✅ Avoid frequent disposal and re-injection
// Let the reference counting system handle cleanup

// ✅ Use bulk operations for global styles
injectGlobal([
  { selector: 'body', declarations: 'margin: 0;' },
  { selector: '*', declarations: 'box-sizing: border-box;' },
  { selector: '.container', declarations: 'max-width: 1200px;' }
]);

// ✅ Configure appropriate thresholds for your app
configure({
  unusedStylesThreshold: 200,      // Adjust based on component count
  bulkCleanupBatchRatio: 0.4,      // Balance cleanup frequency vs performance
});
```

### Memory Management

```typescript
// The injector automatically manages memory through:

// 1. Hash-based deduplication - same CSS = same className
// 2. Reference counting - styles stay alive while in use
// 3. Aged cleanup - unused styles must remain unused for minimum time
// 4. Partial cleanup - only oldest unused styles are removed per batch
// 5. DOM validation - prevents cleanup of styles still in DOM

// Manual cleanup is rarely needed but available:
cleanup(); // Force immediate cleanup of eligible unused styles
destroy(); // Nuclear option: remove all stylesheets and reset
```

---

## 🔗 Integration with Tasty

The Style Injector is seamlessly integrated with the higher-level Tasty API:

```jsx
// High-level tasty() API
const StyledButton = tasty({
  styles: {
    padding: '2x 4x',
    fill: '#purple',
    color: '#white',
  }
});

// Internally uses the injector:
// 1. Styles are parsed into StyleResult objects
// 2. inject() is called with the parsed results
// 3. Component gets the returned className
// 4. dispose() is called when component unmounts
```

For most development, you'll use the [Tasty style system](/docs/tasty-documentation--docs) rather than the injector directly. The injector provides the high-performance foundation that makes Tasty's declarative styling possible.

---

## 🎯 When to Use Direct Injection

Direct injector usage is recommended for:

- **Custom CSS-in-JS libraries** built on top of Tasty
- **Global styles** that don't fit the component model
- **Third-party integration** where you need low-level CSS control
- **Performance-critical scenarios** where you need direct control
- **Testing utilities** that need to inject or extract CSS

For regular component styling, prefer the [`tasty()` API](/docs/tasty-documentation--docs) which provides a more developer-friendly interface.
