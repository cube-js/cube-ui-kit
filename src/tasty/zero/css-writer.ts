import * as fs from 'fs';
import * as path from 'path';

export interface CSSWriterOptions {
  /** Enable source comments in output (e.g., "from: Button.tsx") */
  devMode?: boolean;
}

interface CSSBlock {
  css: string;
  source?: string;
}

export class CSSWriter {
  private cssBlocks: Map<string, CSSBlock> = new Map();
  private outputPath: string;
  private devMode: boolean;

  constructor(outputPath: string, options: CSSWriterOptions = {}) {
    this.outputPath = outputPath;
    this.devMode = options.devMode ?? false;
  }

  /**
   * Add CSS block with deduplication key
   * @param key - Unique key for deduplication
   * @param css - CSS content
   * @param source - Optional source file path (used in devMode)
   */
  add(key: string, css: string, source?: string): void {
    this.cssBlocks.set(key, { css, source });
  }

  /**
   * Prepend CSS block at the beginning (before all existing blocks)
   * @param key - Unique key for deduplication
   * @param css - CSS content
   * @param source - Optional source file path (used in devMode)
   */
  prepend(key: string, css: string, source?: string): void {
    // Create new Map with the prepended entry first
    const newBlocks = new Map<string, CSSBlock>();
    newBlocks.set(key, { css, source });
    for (const [existingKey, existingBlock] of this.cssBlocks) {
      newBlocks.set(existingKey, existingBlock);
    }
    this.cssBlocks = newBlocks;
  }

  /**
   * Check if a key already exists
   */
  has(key: string): boolean {
    return this.cssBlocks.has(key);
  }

  /**
   * Get the number of CSS blocks
   */
  get size(): number {
    return this.cssBlocks.size;
  }

  /**
   * Write all collected CSS to the output file
   */
  write(): void {
    const outputDir = path.dirname(this.outputPath);

    // Ensure directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Combine all CSS blocks with optional source comments
    const cssBlocks: string[] = [];
    for (const block of this.cssBlocks.values()) {
      if (this.devMode && block.source) {
        cssBlocks.push(`/* from: ${block.source} */\n${block.css}`);
      } else {
        cssBlocks.push(block.css);
      }
    }
    const css = cssBlocks.join('\n\n');

    // Add header comment
    const header = `/* Generated by @cube-dev/ui-kit/tasty/zero - DO NOT EDIT */\n\n`;

    fs.writeFileSync(this.outputPath, header + css);
  }

  /**
   * Get all CSS as string (for testing or in-memory use)
   */
  getCSS(): string {
    const cssBlocks: string[] = [];
    for (const block of this.cssBlocks.values()) {
      if (this.devMode && block.source) {
        cssBlocks.push(`/* from: ${block.source} */\n${block.css}`);
      } else {
        cssBlocks.push(block.css);
      }
    }
    return cssBlocks.join('\n\n');
  }

  /**
   * Clear all collected CSS
   */
  clear(): void {
    this.cssBlocks.clear();
  }

  /**
   * Get the output path
   */
  getOutputPath(): string {
    return this.outputPath;
  }
}
